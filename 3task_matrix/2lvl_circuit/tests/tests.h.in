#include <string>
#include <fstream>

#include <gtest/gtest.h>
#include "matrix.h"

using namespace se;

// Configure path to determinant tests
#cmakedefine TEST_DIR_PATH "@TEST_DIR_PATH@"

TEST(MATRIX_TEST, GETTERS_1) {
    Matrix<int> A(5, 6);
    EXPECT_EQ(A.getRows(), 5);
    EXPECT_EQ(A.getColumns(), 6);
}

TEST(MATRIX_TEST, GETTERS_2) {
    Matrix<int> A(1, 1);
    EXPECT_EQ(A.getRows(), 1);
    EXPECT_EQ(A.getColumns(), 1);
}

TEST(MATRIX_TEST, CTORS_1) {
    // Check memory leaks
    Matrix<int> A(3, 2, 1);
    Matrix<int> B({{1, 1}, {1, 1}, {1, 1}});
    EXPECT_EQ(A, B);
}

TEST(MATRIX_TEST, CTORS_2) {
    Matrix<int> A(3, 4);
    Matrix<int> B(A);
    EXPECT_EQ(A, B);
    Matrix<int> C(std::move(A));
    EXPECT_EQ(C, B);
}

TEST(MATRIX_TEST, CTORS_3) {
    // Coercion ctor (memory leaks)
    Matrix<int> A(3, 5);
    Matrix<float> B(A);
}

TEST(MATRIX_TEST, ASSIGN_OP_1) {
    Matrix<int> A(3, 4, 1);
    Matrix<int> B(1, 1);
    B = A;
    EXPECT_EQ(A, B);
}

TEST(MATRIX_TEST, ASSIGN_OP_2) {
    Matrix<int> A(3, 4, 1);
    Matrix<int> B(A);
    Matrix<int> C(1, 1);
    C = std::move(A);
    EXPECT_EQ(C, B);
}

TEST(MATRIX_TEST, ACCESS_1) {
    Matrix<int> A(3, 4, 1);
    A[0][0] = 5;
    EXPECT_EQ(A[0][0], 5);
}

TEST(MATRIX_TEST, ACCESS_2) {
    const Matrix<int> A(3, 4, 1);
    auto value = A[1][2];
    EXPECT_EQ(value, A[1][2]);
}

TEST(MATRIX_TEST, ACCESS_3) {
    Matrix<int> A(3, 4);
    EXPECT_THROW({ A[4][5] = 1; }, std::out_of_range);
}

TEST(MATRIX_TEST, EYE_1) {
    Matrix<int> A({{1, 0, 0}, {0, 1, 0}, {0, 0, 1}});
    Matrix<int> B = Matrix<int>::eye(3);
    EXPECT_EQ(A, B);
}

TEST(MATRIX_TEST, ZERO_1) {
    Matrix<int> A({{0, 0, 0}, {0, 0, 0}, {0, 0, 0}});
    Matrix<int> B = Matrix<int>::zero(3, 3);
    EXPECT_EQ(A, B);
}

TEST(MATRIX_TEST, NEGATE_1) {
    Matrix<int> A(3, 5, 1);
    Matrix<int> B(3, 5, -1);
    EXPECT_EQ(A.negate(), B);
}

TEST(MATRIX_TEST, TRANSPOSE_1) {
    Matrix<int> A({{1, 2, 3}, {4, 5, 6}, {7, 8, 9}});
    Matrix<int> B({{1, 4, 7}, {2, 5, 8}, {3, 6, 9}});
    EXPECT_EQ(A, B.transpose());
}

TEST(MATRIX_TEST, OP_UN_MINUS_1) {
    Matrix<int> A(3, 6, 1);
    Matrix<int> B(3, 6, -1);
    EXPECT_EQ(A, -B);
}

TEST(MATRIX_TEST, OP_PLUS_CHAINED_1) {
    Matrix<int> A(3, 4);
    Matrix<int> B(3, 4, 1);
    EXPECT_EQ(A += B, B);
}

TEST(MATRIX_TEST, OP_PLUS_CHAINED_2) {
    Matrix<int> A(3, 4);
    Matrix<int> B(3, 5, 1);
    EXPECT_THROW({ A += B; }, std::runtime_error);
}

TEST(MATRIX_TEST, OP_MINUS_CHAINED_1) {
    Matrix<int> A(3, 4);
    Matrix<int> B(3, 4, 1);
    EXPECT_EQ(B -= B, A);
}

TEST(MATRIX_TEST, OP_MINUS_CHAINED_2) {
    Matrix<int> A(3, 4);
    Matrix<int> B(3, 5, 1);
    EXPECT_THROW({ B -= A; }, std::runtime_error);
}

TEST(MATRIX_TEST, OP_MUL_BY_SCALAR_CHAINED_1) {
    Matrix<int> A(3, 5, 1);
    Matrix<int> B(3, 5, 6);
    EXPECT_EQ(A * 6, B);
}

TEST(MATRIX_TEST, OP_POW_CHAINED_1) {
    Matrix<int> A = Matrix<int>::eye(3);
    EXPECT_EQ(A ^ 5, A);
}

TEST(MATRIX_TEST, OP_MUL_BY_MATRIX_CHAINED_1) {
    Matrix<int> A({{4, -1}, {2, 3}, {0, -2}});
    Matrix<int> B({{1, 2, 0, -2}, {-2, 3, 0, 5}});
    Matrix<int> C({{6, 5, 0, -13}, {-4, 13, 0, 11}, {4, -6, 0, -10}});
    EXPECT_EQ(A *= B, C);
}

TEST(MATRIX_TEST, OP_MUL_BY_MATRIX_CHAINED_2) {
    Matrix<int> A({{4, -1, 1}, {2, 3, 0}, {0, -2, 3}});
    Matrix<int> B({{1, 2, 0, -2}, {-2, 3, 0, 5}});
    EXPECT_THROW({ A *= B; }, std::logic_error);
}

TEST(MATRIX_TEST, REMOVE_COLUMN_1) {
    Matrix<int> A({{1, 3, -2}, {0, 2, 7}, {3, -1, 0}});
    Matrix<int> B({{1, -2}, {0, 7}, {3, 0}});
    EXPECT_EQ(A.removeColumn(1), B);
}

TEST(MATRIX_TEST, REMOVE_COLUMN_2) {
    Matrix<int> A({{1, 3, -2}, {0, 2, 7}, {3, -1, 0}});
    EXPECT_THROW({ A.removeColumn(5); }, std::out_of_range);
}

TEST(MATRIX_TEST, REPLACE_ROW_1) {
    Matrix<int> A({{1, 3, -2}, {0, 2, 7}, {3, -1, 0}});
    Matrix<int> B({{1, 7, 8}});
    Matrix<int> C({{1, 3, -2}, {1, 7, 8}, {3, -1, 0}});
    EXPECT_EQ(C, A.replaceRow(B, 1));
}

TEST(MATRIX_TEST, REPLACE_ROW_2) {
    Matrix<int> A({{1, 3, -2}, {0, 2, 7}, {3, -1, 0}});
    Matrix<int> B({{1, 7, 8}, {2, 4, -5}});
    EXPECT_THROW({ A.replaceRow(B, 1); }, std::out_of_range);
}

TEST(MATRIX_TEST, REPLACE_ROW_FROM_1) {
    Matrix<int> A({{1, 3, -2}, {0, 2, 7}, {3, -1, 0}});
    Matrix<int> B({{4, -1, 1}, {2, 3, 0}, {0, -2, 3}});
    Matrix<int> C({{1, 3, -2}, {2, 3, 0}, {3, -1, 0}});
    EXPECT_EQ(A.replaceRowFrom(B, 1), C);
}

TEST(MATRIX_TEST, REPLACE_ROW_FROM_2) {
    Matrix<int> A({{1, 3, -2}, {0, 2, 7}, {3, -1, 0}});
    Matrix<int> B({{4, -1, 1}, {2, 3, 0}, {0, -2, 3}});
    EXPECT_THROW({ A.replaceRowFrom(B, 3); }, std::out_of_range);
}


TEST(MATRIX_TEST, REPLACE_COLUMN_1) {
    Matrix<int> A({{1, 3, -2}, {0, 2, 7}, {3, -1, 0}});
    Matrix<int> B({{1}, {7}, {8}});
    Matrix<int> C({{1, 1, -2}, {0, 7, 7}, {3, 8, 0}});
    EXPECT_EQ(C, A.replaceColumn(B, 1));
}

TEST(MATRIX_TEST, REPLACE_COLUMN_2) {
    Matrix<int> A({{1, 3, -2}, {0, 2, 7}, {3, -1, 0}});
    Matrix<int> B({{1, 7, 8}});
    EXPECT_THROW({ A.replaceColumn(B, 1); }, std::out_of_range);
}

TEST(MATRIX_TEST, REPLACE_COLUMN_FROM_1) {
    Matrix<int> A({{1, 3, -2}, {0, 2, 7}, {3, -1, 0}});
    Matrix<int> B({{4, -1, 1}, {2, 3, 0}, {0, -2, 3}});
    Matrix<int> C({{1, -1, -2}, {0, 3, 7}, {3, -2, 0}});
    EXPECT_EQ(A.replaceColumnFrom(B, 1), C);
}

TEST(MATRIX_TEST, REPLACE_COLUMN_FROM_2) {
    Matrix<int> A({{1, 3, -2}, {0, 2, 7}, {3, -1, 0}});
    Matrix<int> B({{4, -1, 1}, {2, 3, 0}, {0, -2, 3}});
    EXPECT_THROW({ A.replaceColumnFrom(B, 3); }, std::out_of_range);
}

TEST(MATRIX_TEST, SWAP_ROWS_1) {
    Matrix<int> A({{1, 3, -2}, {0, 2, 7}, {3, -1, 0}});
    Matrix<int> B({{1, 3, -2}, {3, -1, 0}, {0, 2, 7}});
    EXPECT_EQ(A.swapRows(1, 2), B);
}

TEST(MATRIX_TEST, SWAP_ROWS_2) {
    Matrix<int> A({{1, 3, -2}, {0, 2, 7}, {3, -1, 0}});
    EXPECT_THROW({ A.swapRows(2, 3); }, std::out_of_range);
}

TEST(MATRIX_TEST, SUB_ROWS_1) {
    Matrix<int> A({{1, 3, -2}, {0, 2, 7}, {3, -1, 0}});
    Matrix<int> B({{0, 0, 0}, {0, 2, 7}, {3, -1, 0}});
    EXPECT_EQ(B, A.subRows(0, 0, 1));
}

TEST(MATRIX_TEST, SUB_ROWS_2) {
    Matrix<int> A({{1, 3, -2}, {0, 2, 7}, {3, -1, 0}});
    EXPECT_THROW({A.subRows(4, 7, -2); }, std::out_of_range);
}

TEST(MATRIX_TEST, DETERMINANT) {
    std::size_t ntests = 7; // number of tests
    std::size_t matrix_size = 0;
    std::string ext = ".txt";
    std::string test_file = "/det_test";
    std::string ans_file = "/det_ans";
    long double ans = 0;

    for (std::size_t i = 0; i < ntests; ++i) {
        std::cout << "Case #" << i + 1 << std::endl; 
        std::ifstream input(TEST_DIR_PATH + test_file + std::to_string(i + 1) + ext);    
        input >> matrix_size;

        Matrix<long double> matrix(matrix_size, matrix_size);
        for (std::size_t j = 0; j < matrix_size; ++j)
            for (std::size_t k = 0; k < matrix_size; ++k) {
                input >> matrix[j][k];
        }
        std::ifstream output(TEST_DIR_PATH + ans_file + std::to_string(i + 1) + ext);
        output >> ans;
        EXPECT_FLOAT_EQ(ans, matrix.determinant());
    }   
}

TEST(MATRIX_TEST, MINOR_1) {
    Matrix<int> A({{1, 3, -2}, {0, 2, 7}, {3, -1, 0}});
    int res = 7;
    EXPECT_EQ(res, A.getMinor(0, 0));
}

TEST(MATRIX_TEST, MINOR_2) {
    Matrix<int> A({{1, 3, -2}, {0, 2, 7}, {3, -1, 0}});
    EXPECT_THROW({ A.getMinor(1, 4); }, std::out_of_range);
}

TEST(MATRIX_TEST, INVERSE_1) {
    Matrix<int> A({{4, 3}, {3, 2}});
    Matrix<int> inversed_A({{-2, 3}, {3, -4}});
    EXPECT_EQ(A.inverse(), inversed_A);
}

TEST(MATRIX_TEST, INVERSE_2) {
    Matrix<int> A({{4, -3}, {-4, 3}});
    EXPECT_THROW({A.inverse(); }, std::logic_error);
}

TEST(MATRIX_TEST, OP_POW_1) {
    Matrix<int> A{{1, -2}, {4, 3}};
    Matrix<int> B{{-7, -8}, {16, 1}};
    EXPECT_EQ(A^2, B);
}

TEST(MATRIX_TEST, OP_PLUS_1) {
    Matrix<int> A(3, 4);
    Matrix<int> B(3, 4, 1);
    EXPECT_EQ(A + B, B);
}

TEST(MATRIX_TEST, OP_PLUS_2) {
    Matrix<int> A(3, 4);
    Matrix<int> B(3, 5, 1);
    EXPECT_THROW({ A + B; }, std::runtime_error);
}

TEST(MATRIX_TEST, OP_MINUS_1) {
    Matrix<int> A(3, 4);
    Matrix<int> B(3, 4, 1);
    EXPECT_EQ(B - B, A);
}

TEST(MATRIX_TEST, OP_MINUS_2) {
    Matrix<int> A(3, 4);
    Matrix<int> B(3, 5, 1);
    EXPECT_THROW({ B - A; }, std::runtime_error);
}


TEST(MATRIX_TEST, OP_MUL_BY_MATRIX_1) {
    Matrix<int> A({{4, -1}, {2, 3}, {0, -2}});
    Matrix<int> B({{1, 2, 0, -2}, {-2, 3, 0, 5}});
    Matrix<int> C({{6, 5, 0, -13}, {-4, 13, 0, 11}, {4, -6, 0, -10}});
    EXPECT_EQ(A * B, C);
}

TEST(MATRIX_TEST, OP_MUL_BY_MATRIX_2) {
    Matrix<int> A({{4, -1, 1}, {2, 3, 0}, {0, -2, 3}});
    Matrix<int> B({{1, 2, 0, -2}, {-2, 3, 0, 5}});
    EXPECT_THROW({ A * B; }, std::logic_error);
}